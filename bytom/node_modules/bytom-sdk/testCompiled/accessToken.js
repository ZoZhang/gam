'use strict';

/* eslint-env mocha */

var bytom = require('../dist/index.js');
var uuid = require('uuid');
var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');

chai.use(chaiAsPromised);
var expect = chai.expect;

var url = 'http://localhost:9888';
var accessToken = '';

var client = new bytom.Client(url, accessToken);

function createToken() {
  return client.accessTokens.create({
    id: 'token-' + uuid.v4()
  });
}

describe('Access token', function () {

  it('creation successful', function () {
    return client.accessTokens.create({
      id: 'another-' + uuid.v4()
    }).then(function (resp) {
      return expect(resp.token).not.to.be.empty;
    });
  });

  it('creation rejected due to duplicate ID', function () {
    return createToken().then(function (token) {
      return expect(client.accessTokens.create({
        id: token.id
      })).to.be.rejectedWith('BTM000');
    });
  });

  it('returned in list after creation', function () {
    var tokenId = void 0;
    return createToken().then(function (token) {
      tokenId = token.id;
      return client.accessTokens.listAll();
    }).then(function (resp) {
      return expect(resp.map(function (item) {
        return item.id;
      })).to.contain(tokenId);
    });
  });

  it('deletion successful', function () {
    return createToken().then(function (token) {
      return client.accessTokens.delete(token.id);
    }).then(function (resp) {
      return expect(resp).to.be.empty;
    });
  });

  it('deletion rejected due to missing ID', function () {
    return createToken().then(function () {
      return expect(client.accessTokens.delete()).to.be.rejectedWith('BTM000');
    });
  });

  it('removed from list after deletion', function () {
    var tokenId = void 0;
    return createToken().then(function (token) {
      tokenId = token.id;
      return client.accessTokens.delete(tokenId);
    }).then(function () {
      return client.accessTokens.listAll();
    }).then(function (resp) {
      return expect(resp.map(function (item) {
        return item.id;
      })).to.not.contain(tokenId);
    });
  });
});